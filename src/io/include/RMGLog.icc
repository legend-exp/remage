#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <cstdio>
#include <cstdarg>

template <typename T>
void RMGLog::Print(RMGLog::LogLevel loglevelfile, RMGLog::LogLevel loglevelscreen, const T& msg, bool prefixed, bool do_flush) {

  // open log file if not opened
  if (RMGLog::IsOpen()) {
    // write message in to log file
    if (loglevelfile >= RMGLog::fMinimumLogLevelFile) {
      if (prefixed) RMGLog::fOutputFileStream << RMGLog::GetPrefix(loglevelfile, RMGLog::fOutputFileStream);
      RMGLog::fOutputFileStream << msg;
      if (do_flush) RMGLog::fOutputFileStream << std::flush;
    }
  }

  // write message to screen
  if (loglevelscreen >= RMGLog::fMinimumLogLevelScreen) {
    std::ostream& strm = loglevelscreen > RMGLog::LogLevel::warning ? std::cout : std::cerr;
    if (prefixed) strm << RMGLog::GetPrefix(loglevelscreen, strm);
    strm << msg;
    if (do_flush) strm << std::flush;
  }
}

// ---------------------------------------------------------

template <typename T>
void RMGLog::Out(RMGLog::LogLevel loglevelfile, RMGLog::LogLevel loglevelscreen, const T& message) {
  // if this is the first call to Out(), call StartupInfo() first
  if (!RMGLog::fFirstOutputDone) RMGLog::StartupInfo();

  RMGLog::Print(loglevelfile, loglevelscreen, message, true);

  // thorw exception if error is fatal
  if (loglevelfile == fatal or loglevelscreen == fatal) {
    throw std::runtime_error("A fatal exception has occurred, the execution cannot continue.");
  }
}

// ---------------------------------------------------------

template <typename T, typename... Args>
void RMGLog::Out(RMGLog::LogLevel loglevelfile, RMGLog::LogLevel loglevelscreen, const T& t, const Args&... args) {

  // if this is the first call to Out(), call StartupInfo() first
  if (!RMGLog::fFirstOutputDone) RMGLog::StartupInfo();

  RMGLog::Print(loglevelfile, loglevelscreen, t, true, false);

  // https://stackoverflow.com/questions/53281096/apply-function-to-all-elements-of-parameter-pack-from-a-variadic-function/53281524
  // The following is a hacky way to have C++17-like behaviour with C++11
  using dummy = int[];
  (void)dummy { 0, (RMGLog::Print(loglevelfile, loglevelscreen, args, false, false), 0)... };

  RMGLog::Print(loglevelfile, loglevelscreen, "\n", false);

  // thorw exception if error is fatal
  if (loglevelfile == fatal or loglevelscreen == fatal) {
    throw std::runtime_error("A fatal exception has occurred, the execution cannot continue.");
  }
}

// ---------------------------------------------------------

template <RMGLog::Ansi color, typename T>
std::string RMGLog::Colorize(const T& msg, std::ostream& os, bool bold) {

  // check terminal capabilities before
  if (!RMGLog::SupportsColors(os)) return msg;

  std::ostringstream ss;
  ss << "\033[" << (bold ? "1;" : "") << color << "m" << msg << "\033[0m";
  return ss.str();
}

// ---------------------------------------------------------

// https://codereview.stackexchange.com/questions/187183/create-a-c-string-using-printf-style-formatting
void RMGLog::OutFormat(RMGLog::LogLevel loglevelfile, RMGLog::LogLevel loglevelscreen, const char *fmt, ...) {

  char buf[256];
  va_list args;
  va_start(args, fmt);
  const auto r = std::vsnprintf(buf, sizeof buf, fmt, args);
  va_end(args);

  // conversion failed
  if (r < 0) {
    RMGLog::Out(RMGLog::error, "Formatting error");
    return;
  }

  // we fit in the buffer
  const size_t len = r;
  if (len < sizeof buf) {
    RMGLog::Out(loglevelfile, loglevelscreen, std::string{buf, len});
    return;
  }

  // we need to allocate scratch memory
  auto vbuf = std::unique_ptr<char[]>(new char[len+1]);
  va_start(args, fmt);
  std::vsnprintf(vbuf.get(), len+1, fmt, args);
  va_end(args);
  RMGLog::Out(loglevelfile, loglevelscreen, std::string{vbuf.get(), len});
}

// ---------------------------------------------------------

void OutFormat(RMGLog::LogLevel loglevel, const char *fmt, ...) {
  va_list args;
  va_start(args, fmt);
  RMGLog::OutFormat(loglevel, loglevel, fmt, args);
  va_end(args);
}

// vim: tabstop=2 shiftwidth=2 expandtab
